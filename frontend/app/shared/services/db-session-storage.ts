import type { Kysely } from "kysely";
import {
	type Cookie,
	type FlashSessionData,
	type SessionData,
	createSessionStorage,
} from "react-router";
import { SimpleIntervalJob, Task, ToadScheduler } from "toad-scheduler";
import { container } from "~/inversify-config.server";
import { kyselyBuilder } from "~/shared/infrastructure/db/db.server";
import type { DB } from "~/shared/infrastructure/db/model/kysely/tables";
import { logger } from "~/shared/services/logging.server";

const scheduler = container.get<ToadScheduler>(ToadScheduler);

/**
 * This creates a session expiry task.
 * The Disadvantage is, that is created only, when the first session is created.
 *
 * @param db the database connection
 */
function createSessionExpiryTask(db: Kysely<DB>) {
	const task = new Task("session expiry", () => {
		return db
			.deleteFrom("session")
			.where("expires", "<", new Date())
			.executeTakeFirst()
			.then(
				(result) => {
					logger.log("debug", `deleted ${result.numDeletedRows} sessions`);
				},
				(error) => {
					logger.log("error", `error deleting sessions: ${error}`);
				},
			);
	});
	const job = new SimpleIntervalJob(
		{ seconds: 60, runImmediately: true },
		task,
		{
			id: "session expiry",
			preventOverrun: true,
		},
	);
	if (!scheduler.existsById("session expiry"))
		scheduler.addSimpleIntervalJob(job);
}

export function createDatabaseSessionStorage({ cookie }: { cookie: Cookie }) {
	const db = kyselyBuilder();
	const maxAge = !cookie.expires
		? 0
		: cookie.expires.getTime() - new Date().getTime();

	// delete expired sessions every minute
	createSessionExpiryTask(db);

	return createSessionStorage({
		cookie,
		async createData(data, expires) {
			const result = await db
				.insertInto("session")
				.values({
					data,
					expires,
				})
				.returning(["id"])
				.executeTakeFirstOrThrow();
			return result.id;
		},
		async readData(
			id,
		): Promise<FlashSessionData<SessionData, SessionData> | null> {
			const result = await db
				.selectFrom("session")
				.where("id", "=", id)
				.selectAll()
				.executeTakeFirst();
			if (!result) {
				return null;
			}
			const now = new Date();
			// accessing an expired session
			// TODO: general session expiry should be handled by pg_cron job or toad_scheduler
			if (result.expires < now) {
				await db.deleteFrom("session").where("id", "=", id).execute();
				return null;
			}
			await db
				.updateTable("session")
				.set({ expires: new Date(now.getTime() + maxAge) })
				.where("id", "=", id)
				.execute();
			// we know what we put in the database (createData, updateData), so we can cast it
			// still the root cause is getting JsonValue
			// (as generated by kysely-generator) compatible with the return type.
			return result.data as unknown as FlashSessionData<
				SessionData,
				SessionData
			>;
		},
		async updateData(id, data, expires) {
			const result = await db
				.selectFrom("session")
				.where("id", "=", id)
				.selectAll()
				.executeTakeFirst();
			if (!result) {
				await db.insertInto("session").values({ id, data, expires }).execute();
			} else {
				await db
					.updateTable("session")
					.set({ data, expires })
					.where("id", "=", id)
					.execute();
			}
		},
		async deleteData(id) {
			await db.deleteFrom("session").where("id", "=", id).execute();
		},
	});
}
